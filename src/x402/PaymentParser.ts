/**
 * @packageDocumentation
 * @module PaymentParser
 * @description
 * Parses and validates x402 Payment Headers.
 * 
 * This module is responsible for decoding the `PAYMENT-REQUIRED` (HTTP 402) header.
 * It handles the mapping of various network identifiers (e.g., "base-mainnet", "chain-1")
 * to the internal Wormhole Chain ID format used by the SDK.
 * 
 * Supports:
 * - Parsing Base64 encoded JSON payment requirements.
 * - Selection of optimal payment method (if server offers options).
 * - Amount normalization (human-readable to BigInt).
 */

import {
  PaymentRequiredResponse,
  PaymentRequirement,
  Payment402Request,
  X402Scheme,
} from '../types/x402';

// Network to Wormhole Chain ID mapping
const NETWORK_TO_CHAIN_ID: Record<string, number> = {
  // Mainnets
  'ethereum-mainnet': 2,
  'ethereum': 2,
  'base-mainnet': 30,
  'base': 30,
  'solana-mainnet': 1,
  'solana': 1,
  'arbitrum-mainnet': 23,
  'arbitrum': 23,
  'optimism-mainnet': 24,
  'optimism': 24,
  'polygon-mainnet': 5,
  'polygon': 5,
  'avalanche-mainnet': 6,
  'avalanche': 6,
  'bsc-mainnet': 4,
  'bsc': 4,
  // Testnets
  'base-sepolia': 10004,
  'ethereum-sepolia': 10002,
  'arbitrum-sepolia': 10003,
  'optimism-sepolia': 10005,
};

export class PaymentParser {
  /**
   * Parse the PAYMENT-REQUIRED header from a 402 response.
   * 
   * The header contains a base64-encoded JSON object with payment requirements.
   * 
   * @param headers - Response headers (case-insensitive lookup)
   * @returns Parsed payment request or null if invalid
   */
  parseHeaders(headers: Record<string, string>): Payment402Request | null {
    // x402 uses PAYMENT-REQUIRED header (case variations for compatibility)
    const paymentRequired =
      headers['payment-required'] ||
      headers['PAYMENT-REQUIRED'] ||
      headers['Payment-Required'];

    if (!paymentRequired) {
      return null;
    }

    try {
      // Decode base64 JSON payload
      const decoded = Buffer.from(paymentRequired, 'base64').toString('utf-8');
      const data = JSON.parse(decoded) as PaymentRequiredResponse | PaymentRequirement;

      // Handle both array format and single requirement
      let requirement: PaymentRequirement;

      if ('paymentRequirements' in data && Array.isArray(data.paymentRequirements)) {
        // Standard x402 format with array of requirements
        // Select the first valid requirement (could be extended to prefer certain schemes/networks)
        const validRequirement = this.selectBestRequirement(data.paymentRequirements);
        if (!validRequirement) {
          console.error('[x402] No supported payment requirement found');
          return null;
        }
        requirement = validRequirement;
      } else {
        // Legacy/simplified format with single requirement
        requirement = data as PaymentRequirement;
      }

      return this.requirementToRequest(requirement);
    } catch (e) {
      console.error('[x402] Failed to parse PAYMENT-REQUIRED header:', e);
      return null;
    }
  }

  /**
   * Select the best payment requirement based on supported schemes/networks.
   * Prefers 'exact' scheme on supported networks.
   */
  private selectBestRequirement(requirements: PaymentRequirement[]): PaymentRequirement | null {
    // Priority: exact scheme on known networks
    const exactOnKnownNetwork = requirements.find(
      (r) => r.scheme === 'exact' && this.isNetworkSupported(r.network)
    );
    if (exactOnKnownNetwork) return exactOnKnownNetwork;

    // Fallback: any requirement on known network
    const anyOnKnownNetwork = requirements.find((r) => this.isNetworkSupported(r.network));
    if (anyOnKnownNetwork) return anyOnKnownNetwork;

    // Last resort: first requirement
    return requirements[0] || null;
  }

  /**
   * Check if a network is supported.
   */
  private isNetworkSupported(network: string): boolean {
    return network in NETWORK_TO_CHAIN_ID || /^\d+$/.test(network);
  }

  /**
   * Convert a PaymentRequirement to internal Payment402Request format.
   */
  private requirementToRequest(req: PaymentRequirement): Payment402Request {
    return {
      amount: req.maxAmountRequired,
      token: req.asset,
      recipient: req.payTo,
      chain: this.mapNetworkToChainId(req.network),
      network: req.network,
      scheme: req.scheme || 'exact',
      facilitator: req.facilitator,
      nonce: undefined, // Will be generated by signer
      deadline: undefined, // Will be calculated by signer
      original: req,
    };
  }

  /**
   * Map network identifier to Wormhole chain ID.
   * 
   * @param network - Network identifier (e.g., 'base-mainnet', 'ethereum', or numeric string)
   * @returns Wormhole chain ID
   */
  private mapNetworkToChainId(network: string): number {
    // Check direct mapping
    if (network in NETWORK_TO_CHAIN_ID) {
      return NETWORK_TO_CHAIN_ID[network];
    }

    // Handle numeric network IDs (EVM chain IDs or Wormhole IDs)
    const numericId = parseInt(network, 10);
    if (!isNaN(numericId)) {
      // Map common EVM chain IDs to Wormhole chain IDs
      const evmToWormhole: Record<number, number> = {
        1: 2,        // Ethereum Mainnet
        8453: 30,    // Base Mainnet
        42161: 23,   // Arbitrum One
        10: 24,      // Optimism
        137: 5,      // Polygon
        43114: 6,    // Avalanche
        56: 4,       // BSC
        84532: 10004, // Base Sepolia
        11155111: 10002, // Ethereum Sepolia
      };

      if (numericId in evmToWormhole) {
        return evmToWormhole[numericId];
      }

      // Assume it's already a Wormhole chain ID
      return numericId;
    }

    console.warn(`[x402] Unknown network: ${network}, defaulting to Base (30)`);
    return 30; // Default to Base
  }

  /**
   * Parse amount string to BigInt with proper decimal handling.
   * 
   * @param amount - Amount string (could be in wei or human-readable)
   * @param decimals - Token decimals (default 6 for stablecoins)
   */
  parseAmount(amount: string, decimals: number = 6): bigint {
    // If it looks like a decimal number, convert it
    if (amount.includes('.')) {
      const [whole, fraction = ''] = amount.split('.');
      const paddedFraction = fraction.padEnd(decimals, '0').slice(0, decimals);
      return BigInt(whole + paddedFraction);
    }

    // Already in smallest unit
    return BigInt(amount);
  }

  /**
   * Format amount from smallest unit to human-readable.
   * 
   * @param amount - Amount in smallest unit
   * @param decimals - Token decimals
   */
  formatAmount(amount: bigint | string, decimals: number = 6): string {
    const amountBig = typeof amount === 'string' ? BigInt(amount) : amount;
    const divisor = BigInt(10 ** decimals);
    const whole = amountBig / divisor;
    const fraction = amountBig % divisor;

    if (fraction === 0n) {
      return whole.toString();
    }

    const fractionStr = fraction.toString().padStart(decimals, '0');
    return `${whole}.${fractionStr}`.replace(/\.?0+$/, '');
  }
}
